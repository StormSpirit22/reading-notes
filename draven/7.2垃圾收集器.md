# 7.2 垃圾收集器

以下内容引用自 [垃圾收集器](https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/#72-垃圾收集器) -- Draveness。

## 设计原理

暂停程序（Stop the world，STW），随着用户程序申请越来越多的内存，系统中的垃圾也逐渐增多；当程序的内存占用达到一定阈值时，整个应用程序就会全部暂停，垃圾收集器会扫描已经分配的所有对象并回收不再使用的内存空间，当这个过程结束后，用户程序才可以继续执行，Go 语言在早期也使用这种策略实现垃圾收集，但是今天的实现已经复杂了很多。

### 三色抽象 [#](https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/#三色抽象)

为了解决原始标记清除算法带来的长时间 STW，多数现代的追踪式垃圾收集器都会实现三色标记算法的变种以缩短 STW 的时间。三色标记算法将程序中的对象分成白色、黑色和灰色三类[4](https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/#fn:4)：

- 白色对象 — 潜在的垃圾，其内存可能会被垃圾收集器回收；
- 黑色对象 — 活跃的对象，包括不存在任何引用外部指针的对象以及从根对象可达的对象；
- 灰色对象 — 活跃的对象，因为存在指向白色对象的外部指针，垃圾收集器会扫描这些对象的子对象；

![tri-color-objects](https://img.draveness.me/2020-03-16-15843705141808-tri-color-objects.png)



在垃圾收集器开始工作时，程序中不存在任何的黑色对象，垃圾收集的根对象会被标记成灰色，垃圾收集器只会从灰色对象集合中取出对象开始扫描，当灰色集合中不存在任何对象时，标记阶段就会结束。

三色标记垃圾收集器的工作原理很简单，我们可以将其归纳成以下几个步骤：

1. 从灰色对象的集合中选择一个灰色对象并将其标记成黑色；
2. 将黑色对象指向的所有对象都标记成灰色，保证该对象和被该对象引用的对象都不会被回收；
3. 重复上述两个步骤直到对象图中不存在灰色对象；

当三色的标记清除的标记阶段结束之后，应用程序的堆中就不存在任何的灰色对象，我们只能看到黑色的存活对象以及白色的垃圾对象，垃圾收集器可以回收这些白色的垃圾，下面是使用三色标记垃圾收集器执行标记后的堆内存，堆中只有对象 D 为待回收的垃圾：

![tri-color-mark-sweep-after-mark-phase](https://img.draveness.me/2020-03-16-15843705141821-tri-color-mark-sweep-after-mark-phase.png)



因为用户程序可能在标记执行的过程中修改对象的指针，所以三色标记清除算法本身是不可以并发或者增量执行的，它仍然需要 STW，想要并发或者增量地标记对象还是需要使用屏障技术。

### 屏障技术 [#](https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/#屏障技术)

内存屏障技术是一种屏障指令，它可以让 CPU 或者编译器在执行内存相关操作时遵循特定的约束，目前多数的现代处理器都会乱序执行指令以最大化性能，但是该技术能够保证内存操作的顺序性，在内存屏障前执行的操作一定会**先于**内存屏障后执行的操作[6](https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/#fn:6)。

想要在并发或者增量的标记算法中保证正确性，我们需要达成以下两种三色不变性（Tri-color invariant）中的一种：

- 强三色不变性 — 黑色对象不会指向白色对象，只会指向灰色对象或者黑色对象；
- 弱三色不变性 — 黑色对象指向的白色对象必须包含一条从灰色对象经由多个白色对象的可达路径[7](https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/#fn:7)；

> 强弱三色不变性的解释可参考：[8.2 写屏障技术](https://golang.design/under-the-hood/zh-cn/part2runtime/ch08gc/barrier/) 。大概原因是：
>
> 可以证明，当以下两个条件同时满足时会破坏垃圾回收器的正确性 [Wilson, 1992]：
>
> - 条件 1: 赋值器修改对象图，导致某一黑色对象引用白色对象；
> - 条件 2: 从灰色对象出发，到达白色对象的、未经访问过的路径被赋值器破坏。
>
> 只要能够避免其中任何一个条件，则不会出现对象丢失的情况，因为：
>
> - 如果条件 1 被避免，则所有白色对象均被灰色对象引用，没有白色对象会被遗漏；
> - 如果条件 2 被避免，即便白色对象的指针被写入到黑色对象中，但从灰色对象出发，总存在一条没有访问过的路径，从而找到到达白色对象的路径，白色对象最终不会被遗漏。
>
> 这也就是强弱三色不变性的来源。

![strong-weak-tricolor-invariant](https://img.draveness.me/2020-03-16-15843705141834-strong-weak-tricolor-invariant.png)

上图分别展示了遵循强三色不变性和弱三色不变性的堆内存，遵循上述两个不变性中的任意一个，我们都能保证垃圾收集算法的正确性，而屏障技术就是在并发或者增量标记过程中保证三色不变性的重要技术。

垃圾收集中的屏障技术更像是一个钩子方法，它是在用户程序读取对象、创建新对象以及更新对象指针时执行的一段代码，根据操作类型的不同，我们可以将它们分成读屏障（Read barrier）和写屏障（Write barrier）两种，因为读屏障需要在读操作中加入代码片段，对用户程序的性能影响很大，所以编程语言往往都会采用写屏障保证三色不变性。

