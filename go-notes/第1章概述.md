# 2. 类型

## 2.5 引用类型

引用类型特指 slice、map、channel 这三种预定义类型。

`new` 函数按指定类型长度分配零值内存，返回指针，并不关心类型内部构造和初始化方式。`new` 也可以为引用类型分配内存，例如 map，它金分配了字典类型本身（实际就是个指针包装）所需内存，并没有分配键值存储内存，也没有初始化散列桶等内部属性，因此它无法正常工作。

引用类型必须使用 `make` 函数创建，编译器会将 `make` 转换为目标类型专用的创建函数或指令，以确保完成全部内存分配和相关属性初始化。



# 3. 表达式

## 3.4 流控制

for

range 会复制目标数据。受直接影响的是数组，可改用数组指针或切片类型。

```go
func main() {
  data := [3]int{10, 20, 30}
  
  for i, x := range data {
    if i == 0 {
      data[0] += 100
      data[1] += 200
      data[2] += 300
    }
    fmt.Printf("x: %d, data: %d\n", x, data[i])
  }
  
  for i, x := range data[:] {
    if i == 0 {
      data[0] += 100
      data[1] += 200
      data[2] += 300
    }
    fmt.Printf("x: %d, data: %d\n", x, data[i])
  }
}
```

输出：

```bash
x: 10, data: 110
x: 20, data: 220										// range 返回的依旧是复制值
x: 30, data: 330

x: 110, data: 210										// 当 i == 0 修改 data 时，x 已经取值，所以是 110
x: 420, data: 420										// 复制的仅是 slice 自身，底层 array 依旧是原对象
x: 630, data: 630
```

从以上结果可以看出，如果想使用 for...range 取出数据改变后“正确”的值，就得使用数组指针或切片来遍历。



# 4. 函数

### 闭包

闭包可以直接引用原环境变量。闭包是函数和引用环境的组合体。正因为闭包通过指针引用环境变量，那么可能会导致其生命周期延长，甚至会被分配到堆内存。另外，还有所谓”延迟求值“的特性。

```go
func test() []func() {
  var s []func()
  
  for i := 0; i < 2; i++ {
    s = append(s, func() {				// 将多个匿名函数添加到列表
      println(&i, i)
    })
  }
  return s												// 返回匿名函数列表
}

func main() {
  for _, f := range test() {			// 迭代执行所有匿名函数
    f()
  }
}
```

输出

```she
0xc000012068 2
0xc000012068 2
```

for 循环复用局部变量 i，那么每次添加的匿名函数引用的自然是同一变量。添加才做仅仅是将匿名函数放入列表，并未执行。因此当 main 执行这些函数时，它们读取的就是 i 最后一次循环的值。

解决方法就是每次用不同的环境变量或传参复制，让各自闭包环境各不相同。

```go
func test() []func() {
  var s []func()
  
  for i := 0; i < 2; i++ {
    x := i									// x 每次循环都重新定义
    s = append(s, func() {
      println(&x, x)
    })
  }
  return s
}
```

输出

```she
0xc000012068 0
0xc000012080 1
```

闭包让我们不用传递参数就可读取或修改环境状态，当然也要为此付出额外代价。对于性能要求较高的场合，须慎重使用。
